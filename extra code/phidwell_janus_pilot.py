#!/usr/bin/env python3"""Î¦-DWELL: JANUS PILOT ANALYZER============================="Who is steering the brain?"This tool implements the Holographic Multiplexing hypothesis:1. The brain stores spatial maps (eigenmodes) in frequency bands.2. Transitions occur when SPECIFIC bands rotate their spatial pattern.3. This script identifies the "Pilot" (the dominant driving band) at every moment.It replaces the "Orthogonal Jump" detector with a "Band-Steering" detector.Usage:    python phidwell_janus_pilot.py path/to/subject/"""import numpy as npimport scipy.signalimport scipy.linalgimport matplotlib.pyplot as pltfrom matplotlib.gridspec import GridSpecimport sysimport osimport globimport warnings# Suppress verbose warningswarnings.filterwarnings('ignore')try:    import mneexcept ImportError:    print("ERROR: mne required. pip install mne")    sys.exit(1)# ==============================================================================# CONFIGURATION# ==============================================================================BANDS = {    'delta': (1, 4), 'theta': (4, 8), 'alpha': (8, 13),    'beta': (13, 30), 'gamma': (30, 50)}BAND_ORDER = ['delta', 'theta', 'alpha', 'beta', 'gamma']BAND_COLORS = ['#d62728', '#ff7f0e', '#2ca02c', '#1f77b4', '#9467bd'] # Red, Orange, Green, Blue, PurpleN_MODES = 8WINDOW_MS = 100STEP_MS = 25# Standard 64-channel 10-10ELECTRODE_POS_64 = {    'Fc5.': (-0.59, 0.31), 'Fc3.': (-0.35, 0.31), 'Fc1.': (-0.12, 0.31),    'Fcz.': (0.0, 0.31), 'Fc2.': (0.12, 0.31), 'Fc4.': (0.35, 0.31),    'Fc6.': (0.59, 0.31), 'C5..': (-0.67, 0.0), 'C3..': (-0.40, 0.0),    'C1..': (-0.13, 0.0), 'Cz..': (0.0, 0.0), 'C2..': (0.13, 0.0),    'C4..': (0.40, 0.0), 'C6..': (0.67, 0.0), 'Cp5.': (-0.59, -0.31),    'Cp3.': (-0.35, -0.31), 'Cp1.': (-0.12, -0.31), 'Cpz.': (0.0, -0.31),    'Cp2.': (0.12, -0.31), 'Cp4.': (0.35, -0.31), 'Cp6.': (0.59, -0.31),    'Fp1.': (-0.25, 0.90), 'Fpz.': (0.0, 0.92), 'Fp2.': (0.25, 0.90),    'Af7.': (-0.52, 0.75), 'Af3.': (-0.25, 0.72), 'Afz.': (0.0, 0.72),    'Af4.': (0.25, 0.72), 'Af8.': (0.52, 0.75), 'F7..': (-0.73, 0.52),    'F5..': (-0.55, 0.52), 'F3..': (-0.35, 0.52), 'F1..': (-0.12, 0.52),    'Fz..': (0.0, 0.52), 'F2..': (0.12, 0.52), 'F4..': (0.35, 0.52),    'F6..': (0.55, 0.52), 'F8..': (0.73, 0.52), 'Ft7.': (-0.80, 0.18),    'Ft8.': (0.80, 0.18), 'T7..': (-0.85, 0.0), 'T8..': (0.85, 0.0),    'T9..': (-0.95, 0.0), 'T10.': (0.95, 0.0), 'Tp7.': (-0.80, -0.18),    'Tp8.': (0.80, -0.18), 'P7..': (-0.73, -0.52), 'P5..': (-0.55, -0.52),    'P3..': (-0.35, -0.52), 'P1..': (-0.12, -0.52), 'Pz..': (0.0, -0.52),    'P2..': (0.12, -0.52), 'P4..': (0.35, -0.52), 'P6..': (0.55, -0.52),    'P8..': (0.73, -0.52), 'Po7.': (-0.45, -0.72), 'Po3.': (-0.25, -0.72),    'Poz.': (0.0, -0.72), 'Po4.': (0.25, -0.72), 'Po8.': (0.45, -0.72),    'O1..': (-0.25, -0.87), 'Oz..': (0.0, -0.87), 'O2..': (0.25, -0.87),    'Iz..': (0.0, -0.95),}# ==============================================================================# 1. CORE MATH# ==============================================================================def build_graph_laplacian(positions, sigma=0.4):    names = sorted(positions.keys())    N = len(names)    coords = np.array([positions[n] for n in names])    A = np.zeros((N, N))    for i in range(N):        for j in range(i+1, N):            d = np.linalg.norm(coords[i] - coords[j])            w = np.exp(-d**2 / (2*sigma**2))            A[i,j] = A[j,i] = w    D = np.diag(A.sum(axis=1))    L = D - A    vals, vecs = scipy.linalg.eigh(L)    return names, vecs[:, 1:N_MODES+1]def map_channels(raw_names, graph_names):    mapping = {}    clean_graph = {n.replace('.', '').lower(): n for n in graph_names}    for i, ch in enumerate(raw_names):        clean = ch.replace('EEG', '').strip().replace('.', '').lower()        if clean in clean_graph:            mapping[i] = graph_names.index(clean_graph[clean])    return mappingdef compute_janus_trajectory(raw, vecs):    """    Returns the 40D trajectory but KEPT in band components.    Shape: (5, N_steps, 8)    """    sfreq = raw.info['sfreq']    data = raw.get_data()    n_samp = data.shape[1]        projected_coeffs = np.zeros((len(BANDS), N_MODES, n_samp))        for bi, band in enumerate(BAND_ORDER):        lo, hi = BANDS[band]        sos = scipy.signal.butter(3, [lo, hi], btype='band', fs=sfreq, output='sos')        filt = scipy.signal.sosfiltfilt(sos, data, axis=1)        analytic = scipy.signal.hilbert(filt, axis=1)        projected_coeffs[bi] = np.abs(np.dot(vecs.T, analytic))    # Transpose to (5 bands, n_samp, 8 modes)    traj_bands = projected_coeffs.transpose(0, 2, 1)        # Smooth & Downsample    win = int(WINDOW_MS * sfreq / 1000)    step = int(STEP_MS * sfreq / 1000)        if win > 1:        traj_bands = scipy.ndimage.uniform_filter1d(traj_bands, size=win, axis=1)            return traj_bands[:, ::step, :], sfreq/step# ==============================================================================# 2. THE PILOT DETECTOR# ==============================================================================def analyze_steering(traj_bands):    """    Determines which band is changing (steering) at each time point.    """    n_bands, n_steps, n_modes = traj_bands.shape        # Calculate Velocity per Band    # Shape: (5, n_steps-1)    velocities = np.zeros((n_bands, n_steps-1))        for b in range(n_bands):        # Euclidean distance between t and t+1 in 8D mode space        diffs = np.diff(traj_bands[b], axis=0)        velocities[b] = np.linalg.norm(diffs, axis=1)            # Total Velocity (Global Speed)    total_velocity = np.sum(velocities, axis=0)        # Steering Contribution (Who is driving?)    # Normalize so sum at each t = 1.0    steering_share = velocities / (total_velocity + 1e-9)        # Co-Steering Matrix (Correlation of velocities)    # Do bands accelerate together?    co_steering = np.corrcoef(velocities)        return velocities, steering_share, co_steering# ==============================================================================# 3. VISUALIZATION# ==============================================================================def plot_janus_dashboard(velocities, steering_share, co_steering, subj_name, fs):    time_axis = np.arange(velocities.shape[1]) / fs        fig = plt.figure(figsize=(20, 14), facecolor='#0a0a12')    gs = GridSpec(3, 2, height_ratios=[1, 1, 1], width_ratios=[3, 1], hspace=0.3, wspace=0.1)        # PANEL 1: ABSOLUTE VELOCITY (The Energy)    ax1 = fig.add_subplot(gs[0, 0])    for b, band in enumerate(BAND_ORDER):        ax1.plot(time_axis, velocities[b], color=BAND_COLORS[b], alpha=0.8, lw=1.5, label=band.capitalize())        ax1.set_title(f"JANUS PILOT: {subj_name} (Absolute Velocity per Band)", fontsize=14, color='white')    ax1.set_ylabel("Change Magnitude (d/dt)", color='white')    ax1.legend(loc='upper right', facecolor='#0a0a12', labelcolor='white')    ax1.set_facecolor('#0a0a12')    ax1.tick_params(colors='white')        # PANEL 2: THE PILOT (Stacked Area - Who is driving?)    ax2 = fig.add_subplot(gs[1, 0], sharex=ax1)    ax2.stackplot(time_axis, steering_share, labels=[b.capitalize() for b in BAND_ORDER], colors=BAND_COLORS, alpha=0.9)        ax2.set_title("STEERING SHARE (Who is driving the trajectory?)", fontsize=14, color='white')    ax2.set_ylabel("Contribution (0-1)", color='white')    ax2.set_ylim(0, 1)    ax2.set_facecolor('#0a0a12')    ax2.tick_params(colors='white')        # PANEL 3: CO-STEERING MATRIX (The Holographic Lock)    ax3 = fig.add_subplot(gs[0:2, 1])    im = ax3.imshow(co_steering, cmap='inferno', vmin=-0.2, vmax=1.0)        # Labels    ax3.set_xticks(np.arange(5))    ax3.set_yticks(np.arange(5))    ax3.set_xticklabels([b.capitalize() for b in BAND_ORDER], rotation=45, color='white')    ax3.set_yticklabels([b.capitalize() for b in BAND_ORDER], color='white')    ax3.set_title("CO-STEERING\n(Correlated Acceleration)", fontsize=12, color='white')        # Annotate values    for i in range(5):        for j in range(5):            text = ax3.text(j, i, f"{co_steering[i, j]:.2f}",                           ha="center", va="center", color="white", fontsize=8)        # PANEL 4: DOMINANT PILOT HISTOGRAM    ax4 = fig.add_subplot(gs[2, :])        # Determine winner at each step    winners = np.argmax(steering_share, axis=0)    counts = [np.sum(winners == i) for i in range(5)]    total = sum(counts)        bars = ax4.bar(BAND_ORDER, counts, color=BAND_COLORS)    ax4.set_title(f"TOTAL TIME AT THE WHEEL (Total Steps: {total})", fontsize=14, color='white')    ax4.set_ylabel("Steps", color='white')    ax4.set_facecolor('#0a0a12')    ax4.tick_params(colors='white')        # Add percentages    for rect, count in zip(bars, counts):        height = rect.get_height()        ax4.text(rect.get_x() + rect.get_width()/2.0, height, f'{count/total:.1%}',                  ha='center', va='bottom', color='white', fontweight='bold')    plt.tight_layout()    out_path = f"janus_pilot_{subj_name}.png"    plt.savefig(out_path, dpi=100, facecolor='#0a0a12')    print(f"\nSaved Janus Dashboard: {out_path}")        return counts# ==============================================================================# MAIN# ==============================================================================if __name__ == "__main__":    if len(sys.argv) < 2:        print("Usage: python phidwell_janus_pilot.py <path_to_subject_or_file>")        sys.exit(1)            path = sys.argv[1]        # Handle Directory    if os.path.isdir(path):        files = glob.glob(os.path.join(path, "*.edf"))        # Prioritize Task files        task_files = [f for f in files if "R04" in f or "R08" in f or "R12" in f]        file_to_run = task_files[0] if task_files else files[0]    else:        file_to_run = path            print(f"Loading: {file_to_run}")        # 1. Init Geometry    graph_names, eigenvecs = build_graph_laplacian(ELECTRODE_POS_64)        # 2. Load Data    raw = mne.io.read_raw_edf(file_to_run, preload=True, verbose='error')    mapping = map_channels(raw.ch_names, graph_names)        data = raw.get_data()    ordered_data = np.zeros((len(graph_names), data.shape[1]))    for raw_idx, graph_idx in mapping.items():        ordered_data[graph_idx] = data[raw_idx]            info = mne.create_info(graph_names, raw.info['sfreq'], ch_types='eeg')    raw_ordered = mne.io.RawArray(ordered_data, info, verbose='error')        # 3. Compute Trajectory    print("Computing Janus Band Trajectories...")    traj_bands, fs_traj = compute_janus_trajectory(raw_ordered, eigenvecs)        # 4. Analyze Steering    print("Identifying the Pilot...")    vels, share, co_matrix = analyze_steering(traj_bands)        # 5. Plot    subj_name = os.path.basename(file_to_run).split('.')[0]    counts = plot_janus_dashboard(vels, share, co_matrix, subj_name, fs_traj)        print("\nPILOT STATISTICS:")    print("-" * 30)    for i, band in enumerate(BAND_ORDER):        print(f"{band.capitalize():<10}: {counts[i]:<5} steps")