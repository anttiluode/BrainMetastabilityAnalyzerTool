#!/usr/bin/env python3"""Î¦-DWELL: JANUS PILOT COMPARISON (Rest vs. Task)===============================================Tests the hypothesis: "Does the brain switch pilots during a task?"1. Loads REST (R01) and MOTOR TASK (R04) for N subjects.2. Computes the 'Steering Share' (who is driving?) for each.3. Generates the 'Pilot Shift' Bar Chart.Hypothesis:  - REST: Delta/Theta dominance (Internal scaffolding).  - TASK: Beta dominance (Motor actuation).Usage:    python phidwell_pilot_comparison.py path/to/dataset/ --subjects 5"""import numpy as npimport scipy.signalimport scipy.linalgimport matplotlib.pyplot as pltfrom matplotlib.gridspec import GridSpecimport sysimport osimport globimport argparseimport warnings# Suppress verbose warningswarnings.filterwarnings('ignore')try:    import mneexcept ImportError:    print("ERROR: mne required. pip install mne")    sys.exit(1)# ==============================================================================# CONFIGURATION# ==============================================================================BANDS = {    'delta': (1, 4), 'theta': (4, 8), 'alpha': (8, 13),    'beta': (13, 30), 'gamma': (30, 50)}BAND_ORDER = ['delta', 'theta', 'alpha', 'beta', 'gamma']BAND_COLORS = ['#d62728', '#ff7f0e', '#2ca02c', '#1f77b4', '#9467bd']N_MODES = 8WINDOW_MS = 100STEP_MS = 25ELECTRODE_POS_64 = {    'Fc5.': (-0.59, 0.31), 'Fc3.': (-0.35, 0.31), 'Fc1.': (-0.12, 0.31),    'Fcz.': (0.0, 0.31), 'Fc2.': (0.12, 0.31), 'Fc4.': (0.35, 0.31),    'Fc6.': (0.59, 0.31), 'C5..': (-0.67, 0.0), 'C3..': (-0.40, 0.0),    'C1..': (-0.13, 0.0), 'Cz..': (0.0, 0.0), 'C2..': (0.13, 0.0),    'C4..': (0.40, 0.0), 'C6..': (0.67, 0.0), 'Cp5.': (-0.59, -0.31),    'Cp3.': (-0.35, -0.31), 'Cp1.': (-0.12, -0.31), 'Cpz.': (0.0, -0.31),    'Cp2.': (0.12, -0.31), 'Cp4.': (0.35, -0.31), 'Cp6.': (0.59, -0.31),    'Fp1.': (-0.25, 0.90), 'Fpz.': (0.0, 0.92), 'Fp2.': (0.25, 0.90),    'Af7.': (-0.52, 0.75), 'Af3.': (-0.25, 0.72), 'Afz.': (0.0, 0.72),    'Af4.': (0.25, 0.72), 'Af8.': (0.52, 0.75), 'F7..': (-0.73, 0.52),    'F5..': (-0.55, 0.52), 'F3..': (-0.35, 0.52), 'F1..': (-0.12, 0.52),    'Fz..': (0.0, 0.52), 'F2..': (0.12, 0.52), 'F4..': (0.35, 0.52),    'F6..': (0.55, 0.52), 'F8..': (0.73, 0.52), 'Ft7.': (-0.80, 0.18),    'Ft8.': (0.80, 0.18), 'T7..': (-0.85, 0.0), 'T8..': (0.85, 0.0),    'T9..': (-0.95, 0.0), 'T10.': (0.95, 0.0), 'Tp7.': (-0.80, -0.18),    'Tp8.': (0.80, -0.18), 'P7..': (-0.73, -0.52), 'P5..': (-0.55, -0.52),    'P3..': (-0.35, -0.52), 'P1..': (-0.12, -0.52), 'Pz..': (0.0, -0.52),    'P2..': (0.12, -0.52), 'P4..': (0.35, -0.52), 'P6..': (0.55, -0.52),    'P8..': (0.73, -0.52), 'Po7.': (-0.45, -0.72), 'Po3.': (-0.25, -0.72),    'Poz.': (0.0, -0.72), 'Po4.': (0.25, -0.72), 'Po8.': (0.45, -0.72),    'O1..': (-0.25, -0.87), 'Oz..': (0.0, -0.87), 'O2..': (0.25, -0.87),    'Iz..': (0.0, -0.95),}# ==============================================================================# 1. CORE MATH# ==============================================================================def build_graph_laplacian(positions, sigma=0.4):    names = sorted(positions.keys())    N = len(names)    coords = np.array([positions[n] for n in names])    A = np.zeros((N, N))    for i in range(N):        for j in range(i+1, N):            d = np.linalg.norm(coords[i] - coords[j])            w = np.exp(-d**2 / (2*sigma**2))            A[i,j] = A[j,i] = w    D = np.diag(A.sum(axis=1))    L = D - A    vals, vecs = scipy.linalg.eigh(L)    return names, vecs[:, 1:N_MODES+1]def map_channels(raw_names, graph_names):    mapping = {}    clean_graph = {n.replace('.', '').lower(): n for n in graph_names}    for i, ch in enumerate(raw_names):        clean = ch.replace('EEG', '').strip().replace('.', '').lower()        if clean in clean_graph:            mapping[i] = graph_names.index(clean_graph[clean])    return mappingdef calculate_pilot_share(raw, vecs):    """    Returns the % of time each band was the 'Pilot' (dominant velocity).    """    sfreq = raw.info['sfreq']    data = raw.get_data()    n_samp = data.shape[1]        # Map raw data to graph nodes    # (Simplified for batch processing - assumes standard mapping works)        # 1. Compute Band Trajectories    projected_coeffs = np.zeros((len(BANDS), N_MODES, n_samp))    for bi, band in enumerate(BAND_ORDER):        lo, hi = BANDS[band]        sos = scipy.signal.butter(3, [lo, hi], btype='band', fs=sfreq, output='sos')        filt = scipy.signal.sosfiltfilt(sos, data, axis=1)        analytic = scipy.signal.hilbert(filt, axis=1)        projected_coeffs[bi] = np.abs(np.dot(vecs.T, analytic))    traj_bands = projected_coeffs.transpose(0, 2, 1) # (5, N, 8)        # Smooth & Downsample    win = int(WINDOW_MS * sfreq / 1000)    step = int(STEP_MS * sfreq / 1000)    if win > 1:        traj_bands = scipy.ndimage.uniform_filter1d(traj_bands, size=win, axis=1)    traj_bands = traj_bands[:, ::step, :]        # 2. Compute Steering    n_bands, n_steps, _ = traj_bands.shape    velocities = np.zeros((n_bands, n_steps-1))        for b in range(n_bands):        diffs = np.diff(traj_bands[b], axis=0)        velocities[b] = np.linalg.norm(diffs, axis=1)        # 3. Determine Winner    steering_share = velocities / (np.sum(velocities, axis=0) + 1e-9)    winners = np.argmax(steering_share, axis=0)        counts = [np.sum(winners == i) for i in range(5)]    total = sum(counts)    return [c/total for c in counts] # Return percentages# ==============================================================================# 2. BATCH PROCESSING# ==============================================================================def process_subject(subj_path, graph_names, vecs):    """Loads R01 and R04 for a subject and computes pilot shares."""    files = glob.glob(os.path.join(subj_path, "*.edf"))        # Find REST (R01 or R02) and TASK (R04, R08, or R12)    rest_file = next((f for f in files if "R01" in f), None)    if not rest_file: rest_file = next((f for f in files if "R02" in f), None)        task_file = next((f for f in files if "R04" in f), None)    if not task_file: task_file = next((f for f in files if "R08" in f), None)        if not rest_file or not task_file:        return None, None            print(f"  Rest: {os.path.basename(rest_file)} | Task: {os.path.basename(task_file)}")        # Process Rest    raw_rest = mne.io.read_raw_edf(rest_file, preload=True, verbose='error')    mapping = map_channels(raw_rest.ch_names, graph_names)    # Reorder data    data_r = raw_rest.get_data()    ordered_r = np.zeros((len(graph_names), data_r.shape[1]))    for r_i, g_i in mapping.items(): ordered_r[g_i] = data_r[r_i]    raw_rest_ordered = mne.io.RawArray(ordered_r, mne.create_info(graph_names, raw_rest.info['sfreq'], 'eeg'), verbose='error')        rest_shares = calculate_pilot_share(raw_rest_ordered, vecs)        # Process Task    raw_task = mne.io.read_raw_edf(task_file, preload=True, verbose='error')    # Reorder data    data_t = raw_task.get_data()    ordered_t = np.zeros((len(graph_names), data_t.shape[1]))    for r_i, g_i in mapping.items(): ordered_t[g_i] = data_t[r_i]    raw_task_ordered = mne.io.RawArray(ordered_t, mne.create_info(graph_names, raw_task.info['sfreq'], 'eeg'), verbose='error')        task_shares = calculate_pilot_share(raw_task_ordered, vecs)        return rest_shares, task_shares# ==============================================================================# 3. PLOTTING# ==============================================================================def plot_comparison(rest_avg, task_avg, n_subjs):    fig, ax = plt.subplots(figsize=(10, 6), facecolor='#0a0a12')        indices = np.arange(5)    width = 0.35        rects1 = ax.bar(indices - width/2, rest_avg, width, label='Rest (R01)', color='#2ca02c', alpha=0.8)    rects2 = ax.bar(indices + width/2, task_avg, width, label='Motor Task (R04)', color='#d62728', alpha=0.8)        ax.set_ylabel('Steering Share (%)', color='white')    ax.set_title(f'THE PILOT SHIFT: Rest vs. Task (N={n_subjs})', color='white', fontsize=14, fontweight='bold')    ax.set_xticks(indices)    ax.set_xticklabels([b.capitalize() for b in BAND_ORDER], color='white')    ax.legend(facecolor='#0a0a12', labelcolor='white')    ax.set_facecolor('#0a0a12')    ax.tick_params(colors='white')    ax.grid(color='white', alpha=0.1, axis='y')        # Annotate delta    change_beta = task_avg[3] - rest_avg[3]    change_delta = task_avg[0] - rest_avg[0]        plt.text(3, task_avg[3] + 0.02, f"+{change_beta*100:.1f}%", ha='center', color='#d62728', fontweight='bold')    plt.text(0, rest_avg[0] + 0.02, f"{change_delta*100:.1f}%", ha='center', color='#2ca02c', fontweight='bold')        plt.tight_layout()    plt.savefig('pilot_shift_result.png', dpi=150, facecolor='#0a0a12')    print("\nSaved Result: pilot_shift_result.png")# ==============================================================================# MAIN# ==============================================================================if __name__ == "__main__":    parser = argparse.ArgumentParser()    parser.add_argument('path', help='Path to dataset root')    parser.add_argument('--subjects', type=int, default=5, help='Number of subjects')    args = parser.parse_args()        # Init Geometry    graph_names, eigenvecs = build_graph_laplacian(ELECTRODE_POS_64)        # Find Subjects    subj_dirs = sorted(glob.glob(os.path.join(args.path, "S*")))[:args.subjects]        all_rest = []    all_task = []        print(f"Comparing Pilots for {len(subj_dirs)} subjects...")    print("-" * 50)        for s_dir in subj_dirs:        print(f"Processing {os.path.basename(s_dir)}...")        r, t = process_subject(s_dir, graph_names, eigenvecs)        if r and t:            all_rest.append(r)            all_task.append(t)                if not all_rest:        print("No valid subject data found.")        sys.exit(1)            # Average    avg_rest = np.mean(all_rest, axis=0)    avg_task = np.mean(all_task, axis=0)        print("-" * 50)    print(f"{'BAND':<10} {'REST':<10} {'TASK':<10} {'CHANGE'}")    for i, band in enumerate(BAND_ORDER):        change = avg_task[i] - avg_rest[i]        print(f"{band.capitalize():<10} {avg_rest[i]:.1%}     {avg_task[i]:.1%}     {change:+.1%}")            plot_comparison(avg_rest, avg_task, len(all_rest))