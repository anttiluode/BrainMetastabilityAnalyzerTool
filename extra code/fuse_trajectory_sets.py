#!/usr/bin/env python3"""Φ-DWELL: FLIGHT RECORDER (Trajectory × Sets Fusion)===================================================Merges 'brain_set_system.py' (Set extraction) with 'trajectory_explorer.py' (Geometry).Instead of extracting sets at every time point (noisy), this script acts like a Flight Recorder:1. TRACKING: Monitors the brain's 40D trajectory (8 modes × 5 bands).2. DWELL DETECTION: Waits for Velocity to drop (the brain "arrives" at a thought).3. ORTHOGONALITY CHECK: Measures the angle between the previous thought and current thought.   - If Angle > 80°: ORTHOGONAL JUMP (New Context).   - If Angle < 30°: DRIFT (Same Context).4. LOGGING: Records only the stable, geometrically validated Brain Sets.Usage:    python fuse_trajectory_sets.py path/to/subject_folder/"""import numpy as npimport scipy.signalimport scipy.linalgfrom scipy import statsimport matplotlib.pyplot as pltfrom matplotlib.gridspec import GridSpecimport sysimport osimport globimport warnings# Suppress verbose warningswarnings.filterwarnings('ignore')try:    import mneexcept ImportError:    print("ERROR: mne required. pip install mne")    sys.exit(1)# ==============================================================================# CONFIGURATION# ==============================================================================BANDS = {    'delta': (1, 4), 'theta': (4, 8), 'alpha': (8, 13),    'beta': (13, 30), 'gamma': (30, 50)}BAND_ORDER = ['delta', 'theta', 'alpha', 'beta', 'gamma']N_MODES = 8WINDOW_MS = 100  # 100ms smoothing for trajectorySTEP_MS = 25     # 25ms time steps# Flight Recorder SettingsVELOCITY_THRESHOLD_PERCENTILE = 25  # Below this speed = Dwell (stable thought)ORTHOGONAL_THRESHOLD = 75.0         # Degrees. Above this = New Thought.# Electrodes (Standard 64-channel 10-10)ELECTRODE_POS_64 = {    'Fc5.': (-0.59, 0.31), 'Fc3.': (-0.35, 0.31), 'Fc1.': (-0.12, 0.31),    'Fcz.': (0.0, 0.31), 'Fc2.': (0.12, 0.31), 'Fc4.': (0.35, 0.31),    'Fc6.': (0.59, 0.31), 'C5..': (-0.67, 0.0), 'C3..': (-0.40, 0.0),    'C1..': (-0.13, 0.0), 'Cz..': (0.0, 0.0), 'C2..': (0.13, 0.0),    'C4..': (0.40, 0.0), 'C6..': (0.67, 0.0), 'Cp5.': (-0.59, -0.31),    'Cp3.': (-0.35, -0.31), 'Cp1.': (-0.12, -0.31), 'Cpz.': (0.0, -0.31),    'Cp2.': (0.12, -0.31), 'Cp4.': (0.35, -0.31), 'Cp6.': (0.59, -0.31),    'Fp1.': (-0.25, 0.90), 'Fpz.': (0.0, 0.92), 'Fp2.': (0.25, 0.90),    'Af7.': (-0.52, 0.75), 'Af3.': (-0.25, 0.72), 'Afz.': (0.0, 0.72),    'Af4.': (0.25, 0.72), 'Af8.': (0.52, 0.75), 'F7..': (-0.73, 0.52),    'F5..': (-0.55, 0.52), 'F3..': (-0.35, 0.52), 'F1..': (-0.12, 0.52),    'Fz..': (0.0, 0.52), 'F2..': (0.12, 0.52), 'F4..': (0.35, 0.52),    'F6..': (0.55, 0.52), 'F8..': (0.73, 0.52), 'Ft7.': (-0.80, 0.18),    'Ft8.': (0.80, 0.18), 'T7..': (-0.85, 0.0), 'T8..': (0.85, 0.0),    'T9..': (-0.95, 0.0), 'T10.': (0.95, 0.0), 'Tp7.': (-0.80, -0.18),    'Tp8.': (0.80, -0.18), 'P7..': (-0.73, -0.52), 'P5..': (-0.55, -0.52),    'P3..': (-0.35, -0.52), 'P1..': (-0.12, -0.52), 'Pz..': (0.0, -0.52),    'P2..': (0.12, -0.52), 'P4..': (0.35, -0.52), 'P6..': (0.55, -0.52),    'P8..': (0.73, -0.52), 'Po7.': (-0.45, -0.72), 'Po3.': (-0.25, -0.72),    'Poz.': (0.0, -0.72), 'Po4.': (0.25, -0.72), 'Po8.': (0.45, -0.72),    'O1..': (-0.25, -0.87), 'Oz..': (0.0, -0.87), 'O2..': (0.25, -0.87),    'Iz..': (0.0, -0.95),}# ==============================================================================# 1. CORE MATH: GEOMETRY ENGINE# ==============================================================================def build_graph_laplacian(positions, sigma=0.4):    """Generates the spatial eigenmodes from electrode geometry."""    names = sorted(positions.keys())    N = len(names)    coords = np.array([positions[n] for n in names])        A = np.zeros((N, N))    for i in range(N):        for j in range(i+1, N):            d = np.linalg.norm(coords[i] - coords[j])            w = np.exp(-d**2 / (2*sigma**2))            A[i,j] = A[j,i] = w                D = np.diag(A.sum(axis=1))    L = D - A    vals, vecs = scipy.linalg.eigh(L)    return names, vecs[:, 1:N_MODES+1]  # Skip mode 0 (DC offset)def map_channels(raw_names, graph_names):    """Maps dataset channels to graph nodes."""    mapping = {}    clean_graph = {n.replace('.', '').lower(): n for n in graph_names}    for i, ch in enumerate(raw_names):        clean = ch.replace('EEG', '').strip().replace('.', '').lower()        if clean in clean_graph:            mapping[i] = graph_names.index(clean_graph[clean])    return mappingdef compute_40d_trajectory(raw, vecs):    """    Transforms raw EEG into a 40D trajectory (8 modes * 5 bands).    Returns: (n_steps, 40) matrix    """    sfreq = raw.info['sfreq']    data = raw.get_data()    n_samp = data.shape[1]        # 1. Extract Instantaneous Phase/Amplitude for all bands    # Shape: (5 bands, N_electrodes, N_samples)    projected_coeffs = np.zeros((len(BANDS), N_MODES, n_samp))        for bi, band in enumerate(BAND_ORDER):        lo, hi = BANDS[band]        sos = scipy.signal.butter(3, [lo, hi], btype='band', fs=sfreq, output='sos')                # Filter all channels        filt = scipy.signal.sosfiltfilt(sos, data, axis=1)        # Hilbert        analytic = scipy.signal.hilbert(filt, axis=1)        # Project spatial field onto eigenmodes at every millisecond        # (N_elec, N_samp) -> (N_modes, N_samp)        # We only care about Magnitude (Activation), not Phase angle for the Set logic        # High magnitude = Mode is "Active"        projected_coeffs[bi] = np.abs(np.dot(vecs.T, analytic))    # 2. Reshape to 40D Vector per timepoint    # (5, 8, N) -> (40, N) -> (N, 40)    trajectory_40d = projected_coeffs.reshape(len(BANDS)*N_MODES, n_samp).T        # 3. Smooth trajectory (Moving average) to remove 60Hz noise/jitter    win = int(WINDOW_MS * sfreq / 1000)    if win > 1:        trajectory_40d = scipy.ndimage.uniform_filter1d(trajectory_40d, size=win, axis=0)            # 4. Downsample to step size    step = int(STEP_MS * sfreq / 1000)    return trajectory_40d[::step], sfreq/step# ==============================================================================# 2. FLIGHT RECORDER: KINEMATICS & SET EXTRACTION# ==============================================================================def analyze_flight_path(trajectory, fs):    """    Analyzes the 40D flight path for Speed, Turns, and Stable Sets.    """    # A. Velocity (Speed of thought)    # Euclidean distance between consecutive 40D points    diffs = np.diff(trajectory, axis=0)    velocity = np.linalg.norm(diffs, axis=1)        # B. Curvature (Angle of turn)    # Angle between velocity vector V(t) and V(t+1)    # dot(a,b) / (|a|*|b|) = cos(theta)    v_norm = diffs / (np.linalg.norm(diffs, axis=1, keepdims=True) + 1e-9)    cos_theta = np.sum(v_norm[:-1] * v_norm[1:], axis=1)    curvature_deg = np.degrees(np.arccos(np.clip(cos_theta, -1.0, 1.0)))        # Pad to match length    velocity = np.pad(velocity, (1, 0), 'edge')    curvature_deg = np.pad(curvature_deg, (1, 1), 'edge')        # C. Find "Dwells" (Stable Sets)    # A dwell is where Velocity is LOW.    # The brain slows down to inhabit a state.    vel_thresh = np.percentile(velocity, VELOCITY_THRESHOLD_PERCENTILE)    is_dwell = velocity < vel_thresh        # D. Extract Sets & Transitions    sets = []        # Group consecutive dwell points into "Epochs"    # Scipy label helps find contiguous regions    labeled_dwells, num_features = scipy.ndimage.label(is_dwell)        last_set_vector = None        print(f"\nFLIGHT LOG: Found {num_features} stable dwell epochs (threshold v < {vel_thresh:.2f})")    print(f"{'TIME (s)':<10} {'DUR (ms)':<10} {'TYPE':<15} {'TURN ANGLE':<12} {'DOMINANT MODES'}")    print("-" * 80)        valid_sets_mask = np.zeros(len(trajectory))        for i in range(1, num_features + 1):        indices = np.where(labeled_dwells == i)[0]        if len(indices) < 2: continue # Ignore single-point blips                # 1. Compute Mean State Vector for this Dwell        # Average the 40D vector over the dwell time        dwell_vector = np.mean(trajectory[indices], axis=0)                # 2. Calculate Angle from Previous Set (The "Jump")        jump_angle = 0.0        jump_type = "INIT"        if last_set_vector is not None:            # Angle between two 40D state vectors            # cos = dot(A,B) / |A||B|            denom = (np.linalg.norm(last_set_vector) * np.linalg.norm(dwell_vector))            if denom > 0:                cos_jump = np.dot(last_set_vector, dwell_vector) / denom                jump_angle = np.degrees(np.arccos(np.clip(cos_jump, -1.0, 1.0)))                            if jump_angle > ORTHOGONAL_THRESHOLD:                jump_type = "ORTHO JUMP"            elif jump_angle < 30:                jump_type = "DRIFT"            else:                jump_type = "SHIFT"                # 3. Identify Dominant Modes (The "Set")        # We unflatten the 40D vector back to (5 bands, 8 modes)        matrix = dwell_vector.reshape(5, 8)        # Find max mode per band        dominant_modes = np.argmax(matrix, axis=1) + 1 # 1-based indexing                # Store        start_time = indices[0] / fs        duration = len(indices) / fs * 1000                sets.append({            'start': start_time,            'duration': duration,            'vector': dwell_vector,            'modes': dominant_modes,            'jump_angle': jump_angle,            'type': jump_type        })                # Mark valid sets for plotting        valid_sets_mask[indices] = 1.0                # Log to console        modes_str = " ".join([str(m) for m in dominant_modes])        print(f"{start_time:<10.2f} {duration:<10.0f} {jump_type:<15} {jump_angle:<12.1f} [{modes_str}]")                last_set_vector = dwell_vector    return velocity, curvature_deg, sets, valid_sets_mask# ==============================================================================# 3. VISUALIZATION# ==============================================================================def plot_flight_recorder(velocity, curvature, valid_mask, sets, subject_name, fs):    """Generates the Flight Recorder Dashboard."""    time_axis = np.arange(len(velocity)) / fs        fig = plt.figure(figsize=(20, 12))    gs = GridSpec(3, 1, height_ratios=[1, 1, 1.5], hspace=0.3)        # PANEL 1: VELOCITY (The "Dwell" Detector)    ax1 = fig.add_subplot(gs[0])    # Color line based on Dwell (Blue) vs Transit (Red)    # We do this by plotting points    ax1.plot(time_axis, velocity, color='red', alpha=0.3, label='Transit (High Speed)')    # Overlay dwells    dwell_vel = velocity.copy()    dwell_vel[valid_mask == 0] = np.nan    ax1.plot(time_axis, dwell_vel, color='#00ffcc', lw=2, label='Dwell (Stable Set)')        ax1.set_ylabel("Neural Velocity")    ax1.set_title(f"FLIGHT RECORDER: {subject_name} (Velocity defines Dwells)", fontsize=14, color='white')    ax1.legend(loc='upper right')    ax1.set_facecolor('#0a0a12')    ax1.grid(color='white', alpha=0.1)    # PANEL 2: CURVATURE (The "90-Degree" Validator)    ax2 = fig.add_subplot(gs[1], sharex=ax1)    ax2.plot(time_axis, curvature, color='#ffcc00', lw=1)    ax2.axhline(90, color='red', linestyle='--', alpha=0.5, label='Orthogonal (90°)')    ax2.set_ylabel("Curvature (deg)")    ax2.set_title("TRAJECTORY CURVATURE (Sharp turns = State Switches)", fontsize=12, color='white')    ax2.set_ylim(0, 180)    ax2.set_facecolor('#0a0a12')    ax2.grid(color='white', alpha=0.1)        # PANEL 3: THE BRAIN SET BARCODE    ax3 = fig.add_subplot(gs[2], sharex=ax1)        # Plot sets as blocks    y_band_labels = ['Delta', 'Theta', 'Alpha', 'Beta', 'Gamma']    colors = plt.cm.tab10(np.linspace(0, 1, N_MODES+1))        for s in sets:        t_start = s['start']        dur = s['duration'] / 1000.0        modes = s['modes'] # 5 integers                # Color intensity based on Jump Angle?         # Or just plot the blocks. Let's plot blocks.        alpha = 1.0 if s['type'] == 'ORTHO JUMP' else 0.5                for i, mode_idx in enumerate(modes):            # i = band index (0-4)            # mode_idx = eigenmode (1-8)            rect = plt.Rectangle((t_start, i), dur, 0.8,                                  facecolor=colors[mode_idx],                                  edgecolor='none', alpha=alpha)            ax3.add_patch(rect)                        # Label the 90 degree jumps            if i == 4 and s['type'] == 'ORTHO JUMP':                ax3.text(t_start, 4.8, "90°", color='white', fontsize=7, fontweight='bold')    ax3.set_yticks(np.arange(5) + 0.4)    ax3.set_yticklabels(y_band_labels)    ax3.set_ylim(0, 5.5)    ax3.set_ylabel("Active Eigenmodes")    ax3.set_xlabel("Time (s)")    ax3.set_title("BRAIN SET STATIONS (Validated by Geometry)", fontsize=12, color='white')    ax3.set_facecolor('#0a0a12')        # Dark mode figure    fig.patch.set_facecolor('#050508')    for ax in [ax1, ax2, ax3]:        ax.tick_params(colors='white')        ax.yaxis.label.set_color('white')        ax.xaxis.label.set_color('white')        ax.title.set_color('white')        for spine in ax.spines.values():            spine.set_color('#333')    plt.tight_layout()    out_path = f"flight_recorder_{subject_name}.png"    plt.savefig(out_path, dpi=100)    print(f"\nSaved Flight Recorder: {out_path}")# ==============================================================================# MAIN# ==============================================================================if __name__ == "__main__":    if len(sys.argv) < 2:        print("Usage: python fuse_trajectory_sets.py <path_to_subject_or_edf>")        sys.exit(1)            path = sys.argv[1]        # Handle Directory or Single File    if os.path.isdir(path):        files = glob.glob(os.path.join(path, "*.edf"))        # Prioritize Task files (R04, R08, R12)        task_files = [f for f in files if "R04" in f or "R08" in f or "R12" in f]        file_to_run = task_files[0] if task_files else files[0]    else:        file_to_run = path            print(f"Loading: {file_to_run}")        # 1. Init Geometry    graph_names, eigenvecs = build_graph_laplacian(ELECTRODE_POS_64)        # 2. Load Data & Map    raw = mne.io.read_raw_edf(file_to_run, preload=True, verbose='error')    mapping = map_channels(raw.ch_names, graph_names)        # Reorder raw data to match graph    data = raw.get_data()    ordered_data = np.zeros((len(graph_names), data.shape[1]))    mapped_indices = []        for raw_idx, graph_idx in mapping.items():        ordered_data[graph_idx] = data[raw_idx]        mapped_indices.append(graph_idx)            # Create temp raw object with ordered data for processing    info = mne.create_info(graph_names, raw.info['sfreq'], ch_types='eeg')    raw_ordered = mne.io.RawArray(ordered_data, info, verbose='error')        # 3. Compute 40D Trajectory    print("Computing 40D Eigenmode Trajectory...")    trajectory, fs_traj = compute_40d_trajectory(raw_ordered, eigenvecs)        # 4. Flight Recorder Analysis    print("Analyzing Flight Path Kinematics...")    vel, curv, sets, mask = analyze_flight_path(trajectory, fs_traj)        # 5. Plot    subj_name = os.path.basename(file_to_run).split('.')[0]    plot_flight_recorder(vel, curv, mask, sets, subj_name, fs_traj)        print("\nSUMMARY:")    ortho_jumps = len([s for s in sets if s['type'] == 'ORTHO JUMP'])    print(f"Total Dwells: {len(sets)}")    print(f"Orthogonal (90°) Switches: {ortho_jumps}")    print(f"Avg Dwell Duration: {np.mean([s['duration'] for s in sets]):.1f} ms")