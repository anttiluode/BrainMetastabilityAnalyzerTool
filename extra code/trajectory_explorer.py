#!/usr/bin/env python3"""Φ-Dwell Trajectory Explorer============================See the brain's 40D eigenmode trajectory directly.Instead of tokenizing (collapsing to discrete words), this tool preservesthe full continuous vector: 5 bands × 8 modes = 40 dimensions at every25ms timestep. It computes and visualizes:1. Phase Portrait — PCA projection of the 40D trajectory (the orbit)2. Velocity & Curvature — how fast the brain reconfigures, how sharply it turns3. Recurrence Plot — when the brain revisits previous configurations4. Cross-Band Angles — whether delta and alpha emphasize same spatial patterns5. Manifold Dimension — how many dimensions the brain actually uses6. Band-Resolved Orbits — the 8D sub-trajectory per frequency bandUsage:  python trajectory_explorer.py "physionet.org/files/eegmmidb/1.0.0/S001/"  python trajectory_explorer.py "physionet.org/files/eegmmidb/1.0.0/" --subjects 5"""import sys, os, globimport numpy as npfrom scipy import signal, statsfrom scipy.spatial.distance import pdist, squareformimport warningswarnings.filterwarnings('ignore')# ============================================================================# EIGENMODE BASIS# ============================================================================def build_eigenmodes(electrode_positions, n_modes=8, sigma=0.3):    """Graph Laplacian eigenmodes from electrode geometry."""    pos = np.array(electrode_positions)    n = len(pos)    dist = np.sqrt(((pos[:, None] - pos[None, :]) ** 2).sum(axis=2))    W = np.exp(-dist**2 / (2 * sigma**2))    np.fill_diagonal(W, 0)    D = np.diag(W.sum(axis=1))    L = D - W    vals, vecs = np.linalg.eigh(L)    return vecs[:, 1:n_modes+1], vals[1:n_modes+1]BANDS = {    'delta': (1, 4), 'theta': (4, 8), 'alpha': (8, 13),    'beta': (13, 30), 'gamma': (30, 45)}BAND_NAMES = list(BANDS.keys())# ============================================================================# TRAJECTORY EXTRACTION# ============================================================================def extract_trajectory(data, sfreq, eigenmodes, word_step_ms=25):    """    Extract full 40D trajectory from EEG data.        Returns:        trajectory: (n_steps, 40) array — the brain's path through config space        timestamps: (n_steps,) array — time in seconds    """    n_channels, n_samples = data.shape    n_modes = eigenmodes.shape[1]    n_bands = len(BANDS)    word_step = max(1, int(word_step_ms * sfreq / 1000))    n_steps = n_samples // word_step        trajectory = np.zeros((n_steps, n_bands * n_modes))    timestamps = np.arange(n_steps) * word_step_ms / 1000.0        for bi, (band_name, (flo, fhi)) in enumerate(BANDS.items()):        nyq = sfreq / 2        if fhi >= nyq: fhi = nyq - 1        try:            sos = signal.butter(3, [flo/nyq, fhi/nyq], btype='band', output='sos')            filtered = signal.sosfiltfilt(sos, data, axis=1)        except:            continue                analytic = signal.hilbert(filtered, axis=1)        phase = np.angle(analytic)                for t in range(n_steps):            idx = t * word_step            if idx >= n_samples: break            phase_vec = np.exp(1j * phase[:, idx])            for m in range(n_modes):                proj = np.abs(np.dot(phase_vec, eigenmodes[:, m]))                trajectory[t, bi * n_modes + m] = proj        return trajectory, timestamps# ============================================================================# TRAJECTORY ANALYSIS# ============================================================================def analyze_trajectory(traj, timestamps):    """Compute all trajectory metrics from the 40D path."""    n_steps, n_dim = traj.shape    results = {}        # --- Normalize trajectory ---    traj_norm = (traj - traj.mean(axis=0)) / (traj.std(axis=0) + 1e-8)        # --- 1. PCA: Effective dimensionality ---    cov = np.cov(traj_norm.T)    eigenvalues = np.linalg.eigvalsh(cov)[::-1]    eigenvalues = np.maximum(eigenvalues, 0)    total_var = eigenvalues.sum()    if total_var > 0:        explained = np.cumsum(eigenvalues) / total_var        results['dim_90pct'] = int(np.searchsorted(explained, 0.90) + 1)        results['dim_95pct'] = int(np.searchsorted(explained, 0.95) + 1)        results['dim_80pct'] = int(np.searchsorted(explained, 0.80) + 1)        # Participation ratio (effective dimensionality)        results['participation_ratio'] = float((eigenvalues.sum())**2 / (eigenvalues**2).sum())        results['eigenspectrum'] = eigenvalues[:20].tolist()        # PCA projection for visualization    from numpy.linalg import eigh    _, pca_vecs = eigh(cov)    pca_vecs = pca_vecs[:, ::-1]  # Largest first    traj_pca = traj_norm @ pca_vecs[:, :3]  # Project to 3D    results['traj_pca'] = traj_pca        # --- 2. Velocity and Curvature ---    vel = np.diff(traj_norm, axis=0)  # (n-1, 40)    speed = np.sqrt((vel**2).sum(axis=1))  # scalar speed    results['speed'] = speed    results['mean_speed'] = float(speed.mean())    results['speed_cv'] = float(speed.std() / (speed.mean() + 1e-8))        # Curvature: rate of change of direction    if len(vel) > 1:        vel_norm = vel / (np.sqrt((vel**2).sum(axis=1, keepdims=True)) + 1e-8)        # Angle between successive velocity vectors        dots = np.sum(vel_norm[:-1] * vel_norm[1:], axis=1)        dots = np.clip(dots, -1, 1)        curvature = np.arccos(dots)  # radians        results['curvature'] = curvature        results['mean_curvature'] = float(curvature.mean())        results['curvature_cv'] = float(curvature.std() / (curvature.mean() + 1e-8))        # --- 3. Recurrence ---    # Subsample for computational tractability    step = max(1, n_steps // 800)    traj_sub = traj_norm[::step]    dists = squareform(pdist(traj_sub, 'euclidean'))    # Threshold at 20th percentile of distances    threshold = np.percentile(dists[np.triu_indices_from(dists, k=1)], 15)    recurrence = (dists < threshold).astype(float)    results['recurrence_matrix'] = recurrence    results['recurrence_rate'] = float(recurrence.sum() / recurrence.size)        # Determinism: fraction of recurrent points forming diagonal lines    n_rec = recurrence.shape[0]    diag_lengths = []    for k in range(2, n_rec):        diag = np.diag(recurrence, k)        run = 0        for v in diag:            if v > 0.5:                run += 1            else:                if run >= 2:                    diag_lengths.append(run)                run = 0        if run >= 2:            diag_lengths.append(run)        total_recurrent = recurrence.sum() - n_rec  # exclude diagonal    if total_recurrent > 0 and diag_lengths:        results['determinism'] = float(sum(diag_lengths) / (total_recurrent / 2))    else:        results['determinism'] = 0.0        # --- 4. Cross-band angles ---    n_modes = 8    band_trajs = {}    for bi, bname in enumerate(BAND_NAMES):        band_trajs[bname] = traj_norm[:, bi*n_modes:(bi+1)*n_modes]        cross_angles = {}    pairs = [('delta', 'theta'), ('delta', 'alpha'), ('theta', 'alpha'),             ('alpha', 'beta'), ('beta', 'gamma')]    for b1, b2 in pairs:        v1 = band_trajs[b1]        v2 = band_trajs[b2]        # Normalize each timestep        n1 = v1 / (np.sqrt((v1**2).sum(axis=1, keepdims=True)) + 1e-8)        n2 = v2 / (np.sqrt((v2**2).sum(axis=1, keepdims=True)) + 1e-8)        dots = np.sum(n1 * n2, axis=1)        dots = np.clip(dots, -1, 1)        angles = np.arccos(np.abs(dots))  # 0 = aligned, pi/2 = orthogonal        cross_angles[f'{b1}-{b2}'] = angles        results[f'angle_{b1}_{b2}_mean'] = float(angles.mean())        results[f'angle_{b1}_{b2}_std'] = float(angles.std())        results['cross_angles'] = cross_angles    results['band_trajs'] = band_trajs    results['timestamps'] = timestamps    results['traj_norm'] = traj_norm        return results# ============================================================================# VISUALIZATION# ============================================================================def plot_trajectory(results, subject_name, save_path):    """The big picture: 9-panel trajectory visualization."""    import matplotlib    matplotlib.use('Agg')    import matplotlib.pyplot as plt    from matplotlib.colors import Normalize    from matplotlib.cm import ScalarMappable        fig = plt.figure(figsize=(22, 16))    fig.patch.set_facecolor('#0a0a0f')        # Color scheme    c_traj = '#00e5ff'    c_speed = '#ff6e40'    c_curve = '#eeff41'    c_bands = {'delta': '#ff1744', 'theta': '#ff9100', 'alpha': '#00e676',               'beta': '#2979ff', 'gamma': '#d500f9'}        fig.suptitle(f'Φ-Dwell Trajectory Explorer — {subject_name}',                 color='white', fontsize=16, fontweight='bold', y=0.98)        # === 1. Phase Portrait (PCA 2D) ===    ax1 = fig.add_subplot(3, 3, 1)    ax1.set_facecolor('#0a0a0f')    pca = results['traj_pca']    speed = results['speed']    # Color by speed    colors = plt.cm.inferno(speed / (speed.max() + 1e-8))    ax1.scatter(pca[1:, 0], pca[1:, 1], c=colors, s=0.3, alpha=0.6)    ax1.set_xlabel('PC1', color='white', fontsize=8)    ax1.set_ylabel('PC2', color='white', fontsize=8)    ax1.set_title('Phase Portrait (color = speed)', color='white', fontsize=10)    ax1.tick_params(colors='gray', labelsize=6)    for spine in ax1.spines.values(): spine.set_color('#333')        # === 2. Phase Portrait (PCA 2D, PC2 vs PC3) ===    ax2 = fig.add_subplot(3, 3, 2)    ax2.set_facecolor('#0a0a0f')    ax2.scatter(pca[1:, 1], pca[1:, 2], c=colors, s=0.3, alpha=0.6)    ax2.set_xlabel('PC2', color='white', fontsize=8)    ax2.set_ylabel('PC3', color='white', fontsize=8)    ax2.set_title('Phase Portrait PC2-PC3', color='white', fontsize=10)    ax2.tick_params(colors='gray', labelsize=6)    for spine in ax2.spines.values(): spine.set_color('#333')        # === 3. Eigenspectrum (Manifold Shape) ===    ax3 = fig.add_subplot(3, 3, 3)    ax3.set_facecolor('#0a0a0f')    eigs = results['eigenspectrum']    cumvar = np.cumsum(eigs) / sum(eigs) * 100    ax3.bar(range(len(eigs)), eigs, color=c_traj, alpha=0.7, width=0.8)    ax3_twin = ax3.twinx()    ax3_twin.plot(range(len(eigs)), cumvar, color=c_speed, linewidth=2, marker='o', markersize=3)    ax3_twin.axhline(90, color='gray', linestyle='--', alpha=0.5)    ax3_twin.set_ylabel('Cumul. %', color=c_speed, fontsize=8)    ax3_twin.tick_params(colors=c_speed, labelsize=6)    d90 = results['dim_90pct']    pr = results['participation_ratio']    ax3.set_title(f'Manifold Shape — dim₉₀={d90}, PR={pr:.1f}', color='white', fontsize=10)    ax3.set_xlabel('PC index', color='white', fontsize=8)    ax3.tick_params(colors='gray', labelsize=6)    for spine in ax3.spines.values(): spine.set_color('#333')    for spine in ax3_twin.spines.values(): spine.set_color('#333')        # === 4. Speed Timecourse ===    ax4 = fig.add_subplot(3, 3, 4)    ax4.set_facecolor('#0a0a0f')    t = results['timestamps'][1:]    ax4.plot(t[:len(speed)], speed, color=c_speed, linewidth=0.3, alpha=0.8)    # Smoothed    if len(speed) > 50:        kernel = np.ones(40) / 40        smooth_speed = np.convolve(speed, kernel, mode='same')        ax4.plot(t[:len(smooth_speed)], smooth_speed, color='white', linewidth=1.5, alpha=0.9)    ax4.set_xlabel('Time (s)', color='white', fontsize=8)    ax4.set_ylabel('Speed (40D)', color='white', fontsize=8)    ms = results['mean_speed']    scv = results['speed_cv']    ax4.set_title(f'Trajectory Speed — μ={ms:.2f}, CV={scv:.2f}', color='white', fontsize=10)    ax4.tick_params(colors='gray', labelsize=6)    for spine in ax4.spines.values(): spine.set_color('#333')        # === 5. Curvature Timecourse ===    ax5 = fig.add_subplot(3, 3, 5)    ax5.set_facecolor('#0a0a0f')    curv = results['curvature']    t_curv = results['timestamps'][2:]    ax5.plot(t_curv[:len(curv)], np.degrees(curv), color=c_curve, linewidth=0.3, alpha=0.8)    if len(curv) > 50:        smooth_curv = np.convolve(curv, kernel, mode='same')        ax5.plot(t_curv[:len(smooth_curv)], np.degrees(smooth_curv), color='white', linewidth=1.5)    mc = results['mean_curvature']    ax5.set_xlabel('Time (s)', color='white', fontsize=8)    ax5.set_ylabel('Curvature (°)', color='white', fontsize=8)    ax5.set_title(f'Trajectory Curvature — μ={np.degrees(mc):.1f}°', color='white', fontsize=10)    ax5.tick_params(colors='gray', labelsize=6)    for spine in ax5.spines.values(): spine.set_color('#333')        # === 6. Recurrence Plot ===    ax6 = fig.add_subplot(3, 3, 6)    ax6.set_facecolor('#0a0a0f')    rec = results['recurrence_matrix']    ax6.imshow(rec, cmap='hot', origin='lower', aspect='auto', interpolation='none')    rr = results['recurrence_rate']    det = results['determinism']    ax6.set_title(f'Recurrence — RR={rr:.3f}, DET={det:.3f}', color='white', fontsize=10)    ax6.set_xlabel('Time →', color='white', fontsize=8)    ax6.set_ylabel('Time →', color='white', fontsize=8)    ax6.tick_params(colors='gray', labelsize=6)    for spine in ax6.spines.values(): spine.set_color('#333')        # === 7. Cross-Band Angles ===    ax7 = fig.add_subplot(3, 3, 7)    ax7.set_facecolor('#0a0a0f')    cross = results['cross_angles']    pair_names = list(cross.keys())    for i, pname in enumerate(pair_names):        angles = cross[pname]        # Subsample for plotting        step = max(1, len(angles) // 500)        t_sub = results['timestamps'][::step][:len(angles[::step])]        ax7.plot(t_sub, np.degrees(angles[::step]),                 linewidth=0.8, alpha=0.7, label=pname)    ax7.set_xlabel('Time (s)', color='white', fontsize=8)    ax7.set_ylabel('Angle (°)', color='white', fontsize=8)    ax7.set_title('Cross-Band Eigenmode Angles', color='white', fontsize=10)    ax7.legend(fontsize=6, loc='upper right', facecolor='#1a1a2e', edgecolor='gray',              labelcolor='white')    ax7.tick_params(colors='gray', labelsize=6)    for spine in ax7.spines.values(): spine.set_color('#333')        # === 8. Per-Band PCA Orbits ===    ax8 = fig.add_subplot(3, 3, 8)    ax8.set_facecolor('#0a0a0f')    band_trajs = results['band_trajs']    for bname in BAND_NAMES:        bt = band_trajs[bname]        # PCA to 2D per band        cov_b = np.cov(bt.T)        _, vecs_b = np.linalg.eigh(cov_b)        vecs_b = vecs_b[:, ::-1]        proj_b = bt @ vecs_b[:, :2]        ax8.plot(proj_b[::3, 0], proj_b[::3, 1], color=c_bands[bname],                linewidth=0.3, alpha=0.5, label=bname)    ax8.set_title('Per-Band Orbits (each band\'s 8D→2D)', color='white', fontsize=10)    ax8.legend(fontsize=7, loc='upper right', facecolor='#1a1a2e', edgecolor='gray',              labelcolor='white')    ax8.tick_params(colors='gray', labelsize=6)    for spine in ax8.spines.values(): spine.set_color('#333')        # === 9. Speed-Curvature Phase Space ===    ax9 = fig.add_subplot(3, 3, 9)    ax9.set_facecolor('#0a0a0f')    min_len = min(len(speed), len(curv))    # Color by time    t_colors = plt.cm.viridis(np.linspace(0, 1, min_len))    ax9.scatter(speed[:min_len], np.degrees(curv[:min_len]),                c=t_colors, s=0.5, alpha=0.4)    ax9.set_xlabel('Speed', color='white', fontsize=8)    ax9.set_ylabel('Curvature (°)', color='white', fontsize=8)    ax9.set_title('Speed vs Curvature (color = time)', color='white', fontsize=10)    ax9.tick_params(colors='gray', labelsize=6)    for spine in ax9.spines.values(): spine.set_color('#333')        plt.tight_layout(rect=[0, 0, 1, 0.96])    plt.savefig(save_path, dpi=150, facecolor='#0a0a0f', bbox_inches='tight')    plt.close()    print(f"  Saved: {save_path}")def plot_comparison(all_results, save_path):    """Compare trajectory metrics across subjects."""    import matplotlib    matplotlib.use('Agg')    import matplotlib.pyplot as plt        fig, axes = plt.subplots(2, 3, figsize=(18, 10))    fig.patch.set_facecolor('#0a0a0f')    fig.suptitle(f'Φ-Dwell Trajectory Comparison — {len(all_results)} Subjects',                 color='white', fontsize=14, fontweight='bold')        subjects = list(all_results.keys())    n = len(subjects)    x = range(n)        c1 = '#00e5ff'    c2 = '#ff6e40'    c3 = '#eeff41'    c4 = '#00e676'        def style_ax(ax, title, ylabel):        ax.set_facecolor('#0a0a0f')        ax.set_title(title, color='white', fontsize=10)        ax.set_ylabel(ylabel, color='white', fontsize=8)        ax.tick_params(colors='gray', labelsize=6)        ax.set_xticks(range(n))        ax.set_xticklabels([s.replace('S0','S') for s in subjects], rotation=45, fontsize=7, color='gray')        for spine in ax.spines.values(): spine.set_color('#333')        # 1. Effective dimensionality    ax = axes[0, 0]    d90 = [all_results[s]['dim_90pct'] for s in subjects]    pr = [all_results[s]['participation_ratio'] for s in subjects]    ax.bar(x, d90, color=c1, alpha=0.7, label='dim 90%')    ax_tw = ax.twinx()    ax_tw.plot(x, pr, color=c2, marker='o', markersize=4, label='Part. Ratio')    ax_tw.tick_params(colors=c2, labelsize=6)    for spine in ax_tw.spines.values(): spine.set_color('#333')    style_ax(ax, 'Manifold Dimensionality', 'Dims for 90% var')        # 2. Mean speed    ax = axes[0, 1]    speeds = [all_results[s]['mean_speed'] for s in subjects]    speed_cvs = [all_results[s]['speed_cv'] for s in subjects]    ax.bar(x, speeds, color=c2, alpha=0.7)    style_ax(ax, 'Mean Trajectory Speed', 'Speed (40D norm)')        # 3. Mean curvature    ax = axes[0, 2]    curvs = [np.degrees(all_results[s]['mean_curvature']) for s in subjects]    ax.bar(x, curvs, color=c3, alpha=0.7)    style_ax(ax, 'Mean Curvature', 'Degrees')        # 4. Recurrence metrics    ax = axes[1, 0]    rrs = [all_results[s]['recurrence_rate'] for s in subjects]    dets = [all_results[s]['determinism'] for s in subjects]    width = 0.35    ax.bar([i-width/2 for i in x], rrs, width, color=c1, alpha=0.7, label='Recurrence')    ax.bar([i+width/2 for i in x], dets, width, color=c4, alpha=0.7, label='Determinism')    ax.legend(fontsize=7, facecolor='#1a1a2e', edgecolor='gray', labelcolor='white')    style_ax(ax, 'Recurrence Structure', 'Rate')        # 5. Cross-band angle means    ax = axes[1, 1]    pairs = ['delta-theta', 'delta-alpha', 'theta-alpha', 'alpha-beta', 'beta-gamma']    pair_colors = ['#ff1744', '#ff9100', '#00e676', '#2979ff', '#d500f9']    for pi, pair in enumerate(pairs):        means = [all_results[s].get(f'angle_{pair.replace("-","_")}_mean', 0) for s in subjects]        means = [np.degrees(m) for m in means]        ax.plot(x, means, color=pair_colors[pi], marker='o', markersize=3,                linewidth=1.5, alpha=0.8, label=pair)    ax.legend(fontsize=6, facecolor='#1a1a2e', edgecolor='gray', labelcolor='white', ncol=2)    style_ax(ax, 'Cross-Band Eigenmode Angles', 'Mean Angle (°)')        # 6. Speed CV (burstiness of reconfiguration)    ax = axes[1, 2]    ax.bar(x, speed_cvs, color=c2, alpha=0.7)    curv_cvs = [all_results[s]['curvature_cv'] for s in subjects]    ax_tw = ax.twinx()    ax_tw.plot(x, curv_cvs, color=c3, marker='s', markersize=4)    ax_tw.tick_params(colors=c3, labelsize=6)    for spine in ax_tw.spines.values(): spine.set_color('#333')    style_ax(ax, 'Speed CV (orange) & Curvature CV (yellow)', 'Speed CV')        plt.tight_layout(rect=[0, 0, 1, 0.95])    plt.savefig(save_path, dpi=150, facecolor='#0a0a0f', bbox_inches='tight')    plt.close()    print(f"  Saved: {save_path}")# ============================================================================# MAIN# ============================================================================def load_subject(subject_path):    """Load EEG from PhysioNet subject directory."""    import mne        # Find R01 (eyes open rest)    edf_files = sorted(glob.glob(os.path.join(subject_path, '*.edf')))    if not edf_files:        edf_files = sorted(glob.glob(os.path.join(subject_path, '**', '*.edf'), recursive=True))        # Prefer R01 (rest eyes open)    r01 = [f for f in edf_files if 'R01' in f]    target = r01[0] if r01 else edf_files[0]        raw = mne.io.read_raw_edf(target, preload=True, verbose=False)        # Get electrode positions    try:        mne.datasets.eegbci.standardize(raw)        raw.set_montage(mne.channels.make_standard_montage('standard_1005'), on_missing='ignore')    except:        pass        # Get 3D positions → project to 2D    positions_2d = []    ch_indices = []    montage = raw.get_montage()    if montage is not None:        pos_dict = montage.get_positions()        ch_pos = pos_dict.get('ch_pos', {})        for i, ch in enumerate(raw.ch_names):            if ch in ch_pos:                p = ch_pos[ch]                positions_2d.append([p[0], p[1]])  # x, y                ch_indices.append(i)        if len(positions_2d) < 20:        # Fallback: use all channels with dummy positions        n_ch = len(raw.ch_names)        angles = np.linspace(0, 2*np.pi, n_ch, endpoint=False)        positions_2d = list(zip(np.cos(angles), np.sin(angles)))        ch_indices = list(range(n_ch))        data = raw.get_data()[ch_indices]    sfreq = raw.info['sfreq']        return data, sfreq, np.array(positions_2d), raw.ch_namesdef process_subject(subject_path, output_dir):    """Full pipeline for one subject."""    sub_name = os.path.basename(subject_path.rstrip('/'))    print(f"\n  {sub_name}")        data, sfreq, positions, ch_names = load_subject(subject_path)    print(f"    {len(ch_names)} channels, {sfreq} Hz, {data.shape[1]/sfreq:.0f}s")        eigenmodes, eigenvalues = build_eigenmodes(positions, n_modes=8)    print(f"    8 eigenmodes, λ = {eigenvalues[:4].round(2)}...")        # Limit to 60s for speed    max_samp = min(data.shape[1], int(60 * sfreq))    data = data[:, :max_samp]        traj, timestamps = extract_trajectory(data, sfreq, eigenmodes)    print(f"    Trajectory: {traj.shape[0]} steps × {traj.shape[1]}D")        results = analyze_trajectory(traj, timestamps)    print(f"    Dim 90%: {results['dim_90pct']}, PR: {results['participation_ratio']:.1f}")    print(f"    Speed: μ={results['mean_speed']:.3f}, CV={results['speed_cv']:.2f}")    print(f"    Curvature: μ={np.degrees(results['mean_curvature']):.1f}°")    print(f"    Recurrence: RR={results['recurrence_rate']:.3f}, DET={results['determinism']:.3f}")        # Plot    fig_path = os.path.join(output_dir, f'trajectory_{sub_name}.png')    plot_trajectory(results, sub_name, fig_path)        # Return summary (without large arrays)    summary = {k: v for k, v in results.items()                if not isinstance(v, np.ndarray) and not isinstance(v, dict)}    return summarydef main():    if len(sys.argv) < 2:        print("Usage:")        print("  python trajectory_explorer.py <subject_dir>")        print("  python trajectory_explorer.py <dataset_dir> --subjects 5")        sys.exit(1)        path = sys.argv[1]    n_subjects = 1    if '--subjects' in sys.argv:        idx = sys.argv.index('--subjects')        n_subjects = int(sys.argv[idx + 1])        output_dir = os.path.join(os.path.dirname(path.rstrip('/')), 'trajectory_results')    os.makedirs(output_dir, exist_ok=True)        print(f"\n{'='*60}")    print(f"  Φ-DWELL TRAJECTORY EXPLORER")    print(f"  40D Eigenmode Configuration Space")    print(f"{'='*60}")        # Check if it's a single subject or dataset    edf_here = glob.glob(os.path.join(path, '*.edf'))        if edf_here or n_subjects == 1:        # Single subject        results = process_subject(path, output_dir)    else:        # Multiple subjects        sub_dirs = sorted(glob.glob(os.path.join(path, 'S*')))        if not sub_dirs:            sub_dirs = sorted(glob.glob(os.path.join(path, 'files', 'eegmmidb', '1.0.0', 'S*')))                sub_dirs = sub_dirs[:n_subjects]        print(f"  Processing {len(sub_dirs)} subjects...")                all_results = {}        for sd in sub_dirs:            sub_name = os.path.basename(sd)            try:                summary = process_subject(sd, output_dir)                all_results[sub_name] = summary            except Exception as e:                print(f"    ERROR: {e}")                if len(all_results) >= 2:            comp_path = os.path.join(output_dir, 'trajectory_comparison.png')            plot_comparison(all_results, comp_path)                # Save JSON summary        import json        json_path = os.path.join(output_dir, 'trajectory_summary.json')        # Convert any remaining numpy types        def jsonify(obj):            if isinstance(obj, (np.integer,)): return int(obj)            if isinstance(obj, (np.floating,)): return float(obj)            if isinstance(obj, np.ndarray): return obj.tolist()            return obj                clean = {s: {k: jsonify(v) for k, v in d.items()} for s, d in all_results.items()}        with open(json_path, 'w') as f:            json.dump(clean, f, indent=2)        print(f"\n  Saved: {json_path}")        print(f"\n  Done. Check {output_dir}/")if __name__ == '__main__':    main()